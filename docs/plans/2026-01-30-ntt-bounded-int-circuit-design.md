# NTT BoundedInt Circuit Generator

**Date**: 2026-01-30
**Status**: Design Complete

## Overview

Generate an optimized, fully-unrolled `ntt_512` Cairo function using `BoundedIntCircuit` that produces identical output to the existing recursive `ntt()` in `packages/falcon/src/ntt.cairo`.

## Design Decisions

| Decision | Choice |
|----------|--------|
| Code structure | Fully unrolled (no recursion at runtime) |
| Generator structure | Recursive Python (traces into flat operations) |
| Reduction strategy | Lazy with auto-reduce when bounds exceed 2^64 |
| Input/Output types | `Array<Zq>` with `multi_pop_front::<512>()` |
| Generator location | `hydra/compilable_circuits/ntt.py` |

## Architecture

```
hydra/compilable_circuits/
├── __init__.py
├── ntt.py              # NTT circuit generator
├── regenerate.py       # CLI: python -m hydra.compilable_circuits.regenerate ntt

packages/falcon/src/
├── ntt_bounded_int.cairo  # Generated output (DO NOT EDIT)
├── ntt.cairo              # Existing recursive implementation
└── zq.cairo               # Shared Zq types and operations
```

## Algorithm

The generator uses the same recursive divide-and-conquer algorithm as `falcon_py/ntt.py`:

```python
def ntt(f):
    n = len(f)
    if n == 2:
        # Base case: butterfly with sqr1 = sqrt(-1) mod Q
        f1_j = f[1] * sqr1
        return [f[0] + f1_j, f[0] - f1_j]
    else:
        # Split into even/odd indices
        f0, f1 = split(f)
        # Recursive NTT on each half
        f0_ntt = ntt(f0)
        f1_ntt = ntt(f1)
        # Merge using butterflies with twiddle factors
        return merge_ntt(f0_ntt, f1_ntt)
```

When executed with 512 input variables:
- Recursion depth: 9 levels (log₂(512))
- Total butterfly operations: 2304 (256 per level × 9 levels)
- Operations recorded: ~7000+ (mul, add, sub, reduce)

## Generated Cairo Structure

```cairo
// Auto-generated by hydra/compilable_circuits/ntt.py
// DO NOT EDIT MANUALLY - regenerate with: python -m hydra.compilable_circuits.regenerate ntt

use corelib_imports::bounded_int::{
    BoundedInt, upcast, downcast, bounded_int_div_rem,
    AddHelper, MulHelper, DivRemHelper, UnitInt,
};
use corelib_imports::bounded_int::bounded_int::{SubHelper, add, sub, mul};
use crate::zq::{Zq, from_u16, to_u16, Q};

// === Type aliases for intermediate bounds ===
type ZqProd = BoundedInt<0, 150994944>;
type ZqSumProd = BoundedInt<0, 151007232>;
// ... more as needed based on bounds growth

// === Twiddle factor constants ===
type Sqr1Const = UnitInt<1479>;
const sqr1_const: Sqr1Const = 1479;
// ... 256+ twiddle constants for n=512

// === Helper impls ===
impl MulZqSqr1Impl of MulHelper<Zq, Sqr1Const> {
    type Result = BoundedInt<0, 18173952>;
}
// ... all needed impls

// === Inner computation (512 separate params) ===
fn ntt_512_inner(
    f0: Zq, f1: Zq, f2: Zq, /* ... */ f511: Zq
) -> (Zq, Zq, Zq, /* ... */ Zq) {
    // ~7000 operations fully unrolled
    let tmp_0 = mul(f1, sqr1_const);
    let tmp_1 = add(f0, tmp_0);
    let tmp_2 = sub(f0, tmp_0);
    // ... all operations

    (r0, r1, r2, /* ... */ r511)
}

// === Public API ===
pub fn ntt_512(mut f: Array<Zq>) -> Array<Zq> {
    let f_span = f.span();
    let [f0, f1, f2, /* ... */ f511] = *f_span
        .multi_pop_front::<512>()
        .expect('expected 512 elements');

    let (r0, r1, r2, /* ... */ r511) = ntt_512_inner(f0, f1, /* ... */ f511);

    array![r0, r1, r2, /* ... */ r511]
}
```

## Generator Implementation

### NttCircuitGenerator class

```python
# hydra/compilable_circuits/ntt.py

from bounded_int_circuit import BoundedIntCircuit
from falcon_py.ntt_constants import roots_dict_Zq

class NttCircuitGenerator:
    Q = 12289
    SQR1 = 1479  # sqrt(-1) mod Q = roots_dict_Zq[2][0]

    def __init__(self, n: int = 512):
        self.n = n
        self.circuit = BoundedIntCircuit(f"ntt_{n}_inner", self.Q)
        self._register_constants()

    def _register_constants(self):
        """Register twiddle factors as named constants."""
        self.circuit.register_constant(self.SQR1, "SQR1")
        # Register roots for each merge level
        for size in [4, 8, 16, 32, 64, 128, 256, 512]:
            if size <= self.n:
                roots = roots_dict_Zq[size]
                for i, root in enumerate(roots[::2]):  # even indices only
                    self.circuit.register_constant(root, f"W{size}_{i}")

    def split(self, coeffs):
        """Split list into even/odd indices (compile-time)."""
        return coeffs[::2], coeffs[1::2]

    def merge_ntt(self, f0_ntt, f1_ntt, size):
        """Merge two NTT halves using butterflies."""
        roots = roots_dict_Zq[size]
        result = []
        for i in range(len(f0_ntt)):
            twiddle = self.circuit.constant(roots[2*i], f"w{size}_{i}")
            prod = f1_ntt[i] * twiddle
            even = f0_ntt[i] + prod
            odd = f0_ntt[i] - prod
            result.extend([even, odd])
        return result

    def ntt(self, f):
        """Recursive NTT - operations are traced into circuit."""
        n = len(f)
        if n == 2:
            sqr1 = self.circuit.constant(self.SQR1, "sqr1")
            f1_j = f[1] * sqr1
            even = f[0] + f1_j
            odd = f[0] - f1_j
            return [even, odd]
        else:
            f0, f1 = self.split(f)
            f0_ntt = self.ntt(f0)
            f1_ntt = self.ntt(f1)
            return self.merge_ntt(f0_ntt, f1_ntt, n)

    def generate(self) -> str:
        """Build circuit and compile to Cairo."""
        # Create inputs
        inputs = [
            self.circuit.input(f"f{i}", 0, self.Q - 1)
            for i in range(self.n)
        ]

        # Run NTT (traces all operations)
        outputs = self.ntt(inputs)

        # Mark outputs
        for i, out in enumerate(outputs):
            self.circuit.output(out.reduce(), f"r{i}")

        return self.circuit.compile()

    def simulate(self, values: list[int]) -> list[int]:
        """Execute the traced operations on actual values (for testing)."""
        # Implementation for numerical verification
        ...
```

### Regeneration CLI

```python
# hydra/compilable_circuits/regenerate.py

import argparse
from pathlib import Path

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("circuit", choices=["ntt", "intt", "all"])
    parser.add_argument("--output-dir", default="packages/falcon/src")
    args = parser.parse_args()

    output_dir = Path(args.output_dir)

    if args.circuit in ("ntt", "all"):
        from .ntt import NttCircuitGenerator
        gen = NttCircuitGenerator(512)
        code = gen.generate()
        (output_dir / "ntt_bounded_int.cairo").write_text(code)
        print(f"Generated ntt_bounded_int.cairo")

    # Future: intt, mul_ntt, etc.

if __name__ == "__main__":
    main()
```

## Testing Strategy

### Python Tests (in `hydra/compilable_circuits/test_ntt.py`)

```python
import random
from falcon_py.ntt import ntt as reference_ntt
from .ntt import NttCircuitGenerator

def test_ntt_equivalence():
    random.seed(42)  # Reproducible

    test_cases = [
        list(range(1, 513)),                              # Sequential
        [random.randint(0, 12288) for _ in range(512)],   # Random
        [0] * 512,                                        # All zeros
        [12288] * 512,                                    # All max (Q-1)
        [0 if i % 2 == 0 else 12288 for i in range(512)], # Alternating
    ]

    for i, f in enumerate(test_cases):
        expected = reference_ntt(f[:])
        gen = NttCircuitGenerator(512)
        actual = gen.simulate(f[:])
        assert actual == expected, f"Test case {i} failed"
```

### Cairo Tests (in `packages/falcon/src/tests/ntt_bounded_int_test.cairo`)

```cairo
use falcon::ntt::{ntt};
use falcon::ntt_bounded_int::{ntt_512};
use falcon::zq::{Zq, from_u16, to_u16};

#[test]
fn test_ntt_512_matches_recursive() {
    // Test vector: [1, 2, 3, ..., 512]
    let mut f_array: Array<Zq> = array![];
    let mut i: u16 = 1;
    while i <= 512 {
        f_array.append(from_u16(i));
        i += 1;
    };

    // Reference: existing recursive ntt
    let f_u16: Array<u16> = array![1, 2, 3, /* ... */];
    let expected = ntt(f_u16.span());

    // Generated: BoundedInt ntt_512
    let actual = ntt_512(f_array);

    // Compare all 512 elements
    let mut i = 0;
    while i < 512 {
        assert_eq!(to_u16(*actual[i]), *expected[i]);
        i += 1;
    };
}

#[test]
fn test_ntt_512_all_zeros() {
    let mut f: Array<Zq> = array![];
    let mut i = 0;
    while i < 512 {
        f.append(from_u16(0));
        i += 1;
    };

    let result = ntt_512(f);

    // NTT of all zeros should be all zeros
    let mut i = 0;
    while i < 512 {
        assert_eq!(to_u16(*result[i]), 0);
        i += 1;
    };
}

#[test]
fn test_ntt_512_boundary_values() {
    // All elements at Q-1 = 12288
    let mut f: Array<Zq> = array![];
    let mut i = 0;
    while i < 512 {
        f.append(from_u16(12288));
        i += 1;
    };

    let result = ntt_512(f);

    // Verify against reference
    // ...
}
```

## Implementation Tasks

1. **Create `hydra/compilable_circuits/` module**
   - `__init__.py`
   - `ntt.py` with `NttCircuitGenerator` class
   - `regenerate.py` CLI tool

2. **Extend BoundedIntCircuit if needed**
   - Verify constants handling works for many twiddle factors
   - Add `simulate()` method for numerical verification

3. **Generate `ntt_bounded_int.cairo`**
   - Run generator
   - Verify compilation with `scarb build`

4. **Add Cairo tests**
   - Test equivalence with existing `ntt()`
   - Test boundary values
   - Test random vectors (seeded)

5. **Documentation**
   - Add regeneration instructions to README
   - Document in-code that file is auto-generated

## Expected Statistics

For n=512:
- Input variables: 512
- Output variables: 512
- Butterfly operations: 2304 (256 × 9 stages)
- Total operations: ~7000-9000 (depending on reductions)
- Unique bound types: ~20-50 (depending on lazy reduction)
- Generated code size: ~100-200 KB

## Future Extensions

- `intt_512`: Inverse NTT with same approach
- `mul_ntt_512`: Pointwise multiplication in NTT domain
